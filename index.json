[{"content":"","date":"111124-01-11","externalUrl":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"Cpp","type":"tags"},{"content":"","date":"111124-01-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"111124-01-11","externalUrl":null,"permalink":"/posts/","section":"时间","summary":"","title":"时间","type":"posts"},{"content":"欢迎来到我的网站！我很高兴你的来访。\n如果你遇见[[内容]]均指文章名称，需要自行搜索，才不是我懒得搞了呢😒。 ","date":"111124-01-11","externalUrl":null,"permalink":"/","section":"欢迎来到 Blowfish ！","summary":"","title":"欢迎来到 Blowfish ！","type":"page"},{"content":"","date":"111124-01-11","externalUrl":null,"permalink":"/tags/%E9%93%BE%E8%A1%A8/","section":"Tags","summary":"","title":"链表","type":"tags"},{"content":"这是链表，啥东西都没有。\n回头或许会写东西。。\n","date":"111124-01-11","externalUrl":null,"permalink":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","section":"时间","summary":"","title":"链表","type":"posts"},{"content":"","date":"131327-01-11","externalUrl":null,"permalink":"/tags/uit/","section":"Tags","summary":"","title":"UIT","type":"tags"},{"content":" 啪！很突然就开始考核了，所幸时间相对充裕，但内容过多。。\nUIT2024寒假考核1 # 考核范围：现有成员+二次纳新（Java组除外）\n学习专业基础课程《数据结构》（整本书内容） 链表学生管理系统 命令行应用 需具备基础菜单功能 使用链表完成一份学生管理系统，自主设计学生数据元素； 要求能增加、删除、查询指定条件（学生姓名、性别、年龄等）的学生、显示全部学生数据，保存全部学生数据到文件（txt），并且二次运行时不会丢失数据信息算法组与C++组要求使用C++，其他组C/C++；C++组另需使用OOP对其所实现的链表进行封装 需手动实现链表数据结构，禁止使用STL等现成库 要求提交源码（单个文件），会进行统一查重，并安排时间进行线上腾讯会议答辩（解释程序，依据个人数据结构的学习进度提问） 可以自行添加细节，其余所遇到的疑问请自行搜索，并掌握其内容 ==注意事项：本次考核重在考核基础编码能力与数据结构的学习进度，禁止代码抄袭，二次纳新的同学若有疑问积极提问。== 截止日期：1月19日\n答辩时间：1月21日（若遇特殊情况请事先说明）\n接下来的内容包含剧透内容！！！ 请经过自行思考再进行观看！！！ 1. 考核要求 # 信息概要：\n学 数据结构 整本书 [[链表]]学生管理系统 禁用STL 增加、删除 查询、显示 保存TXT文件 类型: 姓名、性别、年龄、Other 既然禁用STL 我是不是可以把STL库原内容复制过来🤓👆\n2. 框架整体 # 2.1 安全输入 # 方法一：string安全输入 # string input; getline(cin,input); if(input==\u0026#34;add\u0026#34;){ //TODO }else if(input==\u0026#34;\u0026#34;){ //TODO } 方法二：控制台程序的命令行参数输入 # int main(int argc,char* argv[]){ //使用示例 cout\u0026lt;\u0026lt;argc\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;各个参数\u0026#34;\u0026lt;\u0026lt;endl; for (int i=0;i\u0026lt;argc;++i) cout\u0026lt;\u0026lt;argv[i]\u0026lt;\u0026lt;endl; //再自行做个检测 } 方法三：检查输入 # void clearInput() {/*清除错误状态*/ cin.clear();/*辅助函数，用于清理输入流*/ cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); /*忽略错误输入*/ printf(\u0026#34;非法输入，请重新输入！\\n\u0026#34;); } if(cin.fail()||非目标条件){ clearInput(); } 2.2 链表结构 # //结构A typedef struct STU{ string name; string sex; int age; struct STU* next; //结构B //STU(const string\u0026amp; n, const string\u0026amp; s, int a) : name(n), sex(s), age(a), next(nullptr) {} }STU; //侧重抽象，但简单好用(确信 后记一点也不好用 //欸，我有一个大胆的想法🤓👆 typedef struct STU{ int value; struct STU* next; }STU; //初始化head STU *head = nullptr; 冲动了一下，用第二个方案写完发现，不好用，核心内容全部重写了。。。\n//添加 void add(string name,string sex,int year){ //A结构初始化 STU *newstu = new STU(); newstu-\u0026gt;name = name; newstu-\u0026gt;sex = sex; newstu-\u0026gt;age = year; newstu-\u0026gt;next = nullptr; //B结构初始化 //STU *newstu = new STU(name,sex,age); if(find(name)){ cout\u0026lt;\u0026lt;\u0026#34;错误：已存在此人，不支持\u0026#34;\u0026lt;\u0026lt;endl; return ; } if (head == nullptr) { head = newstu; } else { STU *current = head; while (current-\u0026gt;next != nullptr) { current = current-\u0026gt;next; } current-\u0026gt;next = newstu; } } //删除 void del() { string name=input(); //input()输入内容 STU* current=head; STU* t=nullptr; while(current!=nullptr){ if(current-\u0026gt;name==name){ if(t==nullptr){ // current是头节点 head=current-\u0026gt;next; }else{ t-\u0026gt;next=current-\u0026gt;next; } delete current; cout\u0026lt;\u0026lt;\u0026#34;删除成功！\u0026#34;\u0026lt;\u0026lt;endl; save(); return; } t=current; current=current-\u0026gt;next; } cout\u0026lt;\u0026lt;\u0026#34;错误：不存在此人\u0026#34;\u0026lt;\u0026lt;endl; save(); } //查找 int find(string name=input()){ STU* current = head; while(current != nullptr){ if(current-\u0026gt;name == name){ cout\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; return 1; } current=current-\u0026gt;next; } return 0; } //展示全部 void showall(){ if(head==nullptr)cout\u0026lt;\u0026lt;\u0026#34;无学生信息\u0026#34;\u0026lt;\u0026lt;endl; STU* current = head; while(current != nullptr){ cout\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; current=current-\u0026gt;next; } } 2.3 保存与读取 # //保存 void save(){ ofstream file(\u0026#34;stu.txt\u0026#34;); if(file.is_open()){ STU* current = head; while(current != nullptr){ file\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; current=current-\u0026gt;next; } }else{ printf_red(\u0026#34;错误：无法打开文件\\n\u0026#34;); } } //读取 void read() { ifstream file(\u0026#34;stu.txt\u0026#34;); if(file.is_open()){ string name,sex;int age; while(cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;sex\u0026gt;\u0026gt;age) { add(name,sex,age); } file.close(); }else{ cout \u0026lt;\u0026lt; \u0026#34;错误：无法打开文件or未初始化\u0026#34; \u0026lt;\u0026lt; endl; } } Other辅助 # //颜色输出 void printf_red(const char* s){printf(\u0026#34;\\033[0m\\033[1;31m%s\\033[0m\u0026#34;,s);} void printf_green(const char* s){printf(\u0026#34;\\033[0m\\033[1;32m%s\\033[0m\u0026#34;,s);} // 判空 辅助*input*函数 bool isOnlyspace(const string\u0026amp; str) { for (char ch:str) if(!isspace(ch))return true; return false; } //安全输入(获取一整行数据，然后请自行转换) //注意\u0026#34;name\u0026#34;!=\u0026#34;name \u0026#34; string input(string gd=\u0026#34;姓名：\\n\u0026#34;){ cout\u0026lt;\u0026lt;gd; string str; while(true){ getline(cin,str); if(isOnlyspace(str)) break;else cout\u0026lt;\u0026lt;\u0026#34;重新输入\u0026#34;\u0026lt;\u0026lt;endl; } return str; } // 脑抽加密 // 辅助*read* // 结构特征 获取一整行通过split切割转换成新数据包括空格不会被损失 const string split = \u0026#34;*#^\u0026#34;; vector\u0026lt;string\u0026gt; get(string val){ vector\u0026lt;string\u0026gt; stu; //开切 size_t pos; while ((pos = val.find(split)) != string::npos) { stu.push_back(val.substr(0, pos)); val.erase(0, pos + split.length()); } // for(string i:stu)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return stu; } 最终完成 # 完整代码在考核之后展示，其实已经把所有内容展示了。\n//空白 ","date":"131327-01-11","externalUrl":null,"permalink":"/posts/uit2024%E5%AF%92%E5%81%87test1/","section":"时间","summary":"","title":"UIT2024寒假1","type":"posts"},{"content":"","date":"131327-01-11","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":"","date":"131327-01-11","externalUrl":null,"permalink":"/tags/%E8%80%83%E6%A0%B8/","section":"Tags","summary":"","title":"考核","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]