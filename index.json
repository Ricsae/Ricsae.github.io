[{"content":"","date":"22220-01-11","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" py基础语法 # 使用 # # 安装·包· python setup.py install 1.概述 # 1.4.1基础结构 # eval() # # 1.2 x,y=eval(input(\u0026#34;Enter the values of x and y:\u0026#34;)) #输入·1,2·这种结构 sum=x+y print(\u0026#34;The sum of the two numbers is:\u0026#34;,sum) aver=sum/2 print(\u0026#34;The average of the two numbers is:\u0026#34;,aver) eval() 是 Python 中的一个内置函数,它的作用是将字符串作为有效的 Python 表达式来求值并返回结果。\n具体来说,eval() 函数有以下特点:\n接受一个字符串作为参数,并将其作为 Python 代码执行。 可以计算简单的算术表达式,如 eval(\u0026quot;2 + 3\u0026quot;) 会返回 5。 可以执行更复杂的 Python 语句,如函数调用、变量赋值等。 可能存在安全隐患,因为它可以执行任意的 Python 代码,因此应该谨慎使用。 例如:\nx = 10 expression = \u0026#34;x * 2\u0026#34; result = eval(expression) print(result) # Output: 20 在上面的例子中,eval() 函数将字符串 \u0026quot;x * 2\u0026quot; 作为 Python 表达式执行,并返回结果 20。\n需要注意的是,eval() 函数可能存在安全隐患,因为它可以执行任意的 Python 代码。因此,在使用 eval() 时,应该确保输入的字符串是可信的,并且不会执行任何恶意代码。通常情况下,最好使用其他更安全的方法,如使用 ast.literal_eval() 函数来解析字面量表达式。\ndef # # 1.3 def sanjiao(b,h): s=b*h/2 return s print(\u0026#34;The area of the triangle is:\u0026#34;,sanjiao(3,4)) 1.4.2缩进 # m=int(input(\u0026#39;请输入要判断的正整数:\u0026#39;)) flag=1 for i in range(2,m): if m%i==0:#如果m能被i整除，则m不是素数 flag=0 break if flag==1: print(m,\u0026#39;是素数\u0026#39;) else: print(m,\u0026#39;不是素数\u0026#39;) m=int(input(\u0026#39;请输入要判断的正整数:\u0026#39;)) flag=1 for i in range(2,m): if m%i==0:#如果m能被i整除，则m不是素数 flag=0 break if flag==1: print(m,\u0026#39;是素数\u0026#39;) else: print(m,\u0026#39;不是素数\u0026#39;) 两者结果不同，因为缩进不同\n1.4.3注释 # 用'''或者\u0026quot;\u0026quot;\u0026quot;括起来内容\n1.4.4续行 # \\ # \\后面不可以有任何字符 ( ) # 括号中的内容可以分行 1.4.5分隔 # \u0026gt;\u0026gt;\u0026gt;a=1;b=2;c=3 1.5py版本 # 这里只讲解py3的内容，py3采用的编码为UTF-8， 八进制以0o开头\n\u0026gt;\u0026gt;\u0026gt;5/3 1.666666………7 \u0026gt;\u0026gt;\u0026gt;5//3 1 数据类型\nbytes 是 Python 中的一种数据类型,用于表示二进制数据。它是不可变的序列类型,类似于 str 字符串类型,但是存储的是字节而不是字符。\n以下是一些关于 bytes 的重要特点:\n创建 bytes 对象: 可以使用 bytes() 函数创建一个 bytes 对象,例如 b = bytes([1, 2, 3])。 也可以使用字节字面量,例如 b = b'hello'。 访问和修改: bytes 对象是不可变的,意味着你不能修改它的内容。 可以使用索引访问单个字节,例如 b[0] 返回 1。 编码和解码: bytes 对象可以使用 decode() 方法将其转换为字符串,例如 b.decode('utf-8')。 反之,字符串可以使用 encode() 方法转换为 bytes 对象,例如 'hello'.encode('utf-8')。 以下是一个简单的示例:\n# 创建 bytes 对象 b = bytes([1, 2, 3]) print(b) # Output: b\u0026#39;\\x01\\x02\\x03\u0026#39; # 访问单个字节 print(b[0]) # Output: 1 # 解码为字符串 s = b.decode(\u0026#39;utf-8\u0026#39;) print(s) # Output: \u0026#39;\\x01\\x02\\x03\u0026#39; # 将字符串编码为 bytes b2 = \u0026#39;hello\u0026#39;.encode(\u0026#39;utf-8\u0026#39;) print(b2) # Output: b\u0026#39;hello\u0026#39; 总之,bytes 是 Python 中处理二进制数据的重要数据类型,在各种应用场景中都有广泛的使用。\n\u0026gt;\u0026gt;\u0026gt;a=b\u0026#39;Py\u0026#39; \u0026gt;\u0026gt;\u0026gt;a b\u0026#39;Py\u0026#39; \u0026gt;\u0026gt;\u0026gt;type(a) \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;b=a.decode() \u0026gt;\u0026gt;\u0026gt;b \u0026#39;Py\u0026#39; \u0026gt;\u0026gt;\u0026gt;c=b.encode() \u0026gt;\u0026gt;\u0026gt;c b\u0026#39;Py\u0026#39; 2.基础 # 2.1常量、变量和标识符 # “ _ ”表示 上一次运算的结果\n\u0026gt;\u0026gt;\u0026gt;import keyword \u0026gt;\u0026gt;\u0026gt;print(keyword.kwlist) [\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;async\u0026#39;, \u0026#39;await\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;] # 注意bool类型的大小写 \u0026gt;\u0026gt;\u0026gt;keyword.iskeyword(\u0026#39;and\u0026#39;) True 2.2基础数据类型 # 123十进制 0b101二进制 0o7123八进制 0xF``0XAD十六进制\n2.=2.0\npy3.x提供17位有效数字，相当于c的double\n\u0026gt;\u0026gt;\u0026gt;\u0026#34;abc\u0026#34; \u0026#39;abc\u0026#39; \u0026gt;\u0026gt;\u0026gt;\u0026#34;ab\u0026#39;c\u0026#34; \u0026#34;ab\u0026#39;c\u0026#34; \u0026gt;\u0026gt;\u0026gt;\u0026#39;\u0026#39;\u0026#39; 123 \u0026#39;abc\u0026#39; \u0026#39;\u0026#39;\u0026#39; \u0026#34;\\n123\\n\u0026#39;abc\u0026#39;\\n\u0026#34; \u0026gt;\u0026gt;\u0026gt;print(\u0026#34;%s\u0026#34;%(\u0026#39;a\u0026#39;)) a \u0026gt;\u0026gt;\u0026gt;type(True) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;True==1 True \u0026gt;\u0026gt;\u0026gt;True==2 False \u0026gt;\u0026gt;\u0026gt;False\u0026gt;-1 True # 0为空字符串 None为False 其他数值和非空字符为True \u0026gt;\u0026gt;\u0026gt;\u0026#34;\u0026#34; and True \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt;\u0026#34;\u0026#34; and 1 \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt;None or False False # 复数 \u0026gt;\u0026gt;\u0026gt;x=5+3j \u0026gt;\u0026gt;\u0026gt;x.real 5.0 \u0026gt;\u0026gt;\u0026gt;x.imag 3.0 \u0026gt;\u0026gt;\u0026gt;x*x (16+30j) \u0026gt;\u0026gt;\u0026gt;x/x (1+0j) 2.3运算符与表达式 # //整除 **幂运算 %取模 (%2.1有误差的)\n\u0026gt;\u0026gt;\u0026gt;\u0026#39;a\u0026#39;*3 \u0026#39;aaa\u0026#39; 函数 功能 complex(x) 转化为复数，实部x，虚部0 complex(x,y) 转化为复数，实部x，虚部y str(x) chr(x) ord(x) 转ASCII hex(x) 十六进制 oct(x) 八进制 eval(x) 将内容作为表达式 a=b是将b的地址赋给了a\nx,y,z=1,2,3\nx,y=y,x\n优先级 {\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=}大于{= =、！=}\n运算符 含义 结合性 not 非 右结合 and 与 左结合 or 或 左结合 \u0026gt;\u0026gt;\u0026gt;\u0026#39;a\u0026#39; in \u0026#39;abc\u0026#39; True \u0026gt;\u0026gt;\u0026gt;\u0026#39;a\u0026#39; not in \u0026#39;abc\u0026#39; False is用来判断两变量是否是同一个引用 is not id(x)返回引用的内存地址\n2.4math库 # 常数 描述 math.pi math.e math.tau math.inf 正无穷大 math.nan 非浮点数标记 \u0026gt;\u0026gt;\u0026gt;a=float(\u0026#34;inf\u0026#34;) \u0026gt;\u0026gt;\u0026gt;a inf 3.顺序结构程序设计 # 3.3数据的输入与输出 # input([提示字符串]) \u0026#39;4\u0026#39; #字符串 [1,2,3] #列表 (1,2,3) #元组 ","date":"22220-01-11","externalUrl":null,"permalink":"/posts/python/","section":"时间","summary":"","title":"python快速入门","type":"posts"},{"content":"","date":"22220-01-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"欢迎来到我的网站！: )\n","date":"22220-01-11","externalUrl":null,"permalink":"/","section":"欢迎来到 Blowfish ！","summary":"","title":"欢迎来到 Blowfish ！","type":"page"},{"content":"","date":"13130-01-11","externalUrl":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"Cpp","type":"tags"},{"content":"","date":"13130-01-11","externalUrl":null,"permalink":"/tags/uit/","section":"Tags","summary":"","title":"UIT","type":"tags"},{"content":" UIT2024寒假考核1 # 考核范围：现有成员 + 二次纳新 （Java组除外）\n学习专业基础课程 《数据结构》（整本书内容） 链表学生管理系统 命令行应用 需具备基础菜单功能 使用链表完成一份学生管理系统，自主设计学生数据元素； 要求能增加、删除、查询指定条件（学生姓名、性别、年龄等）的学生、显示全部学生数据，保存全部学生数据到文件（txt），并且二次运行时不会丢失数据信息 算法组与 C++ 组 要求使用 C++ ，其他组C/C++；C++ 组另需使用 OOP 对其所实现的链表进行封装 需手动实现链表数据结构，禁止使用 STL等 现成库 要求提交源码（单个文件），会进行统一查重，并安排时间进行线上腾讯会议答辩（解释程序，依据个人数据结构的学习进度提问） 可以自行添加细节，其余所遇到的疑问请自行搜索，并掌握其内容 注意事项：本次考核重在考核基础编码能力与数据结构的学习进度，禁止代码抄袭，二次纳新的同学若有疑问积极提问。 截止日期：1月19日 23:59:59\n*答辩时间：1月20日 （若遇特殊情况请事先说明）\n接下来的内容包含剧透内容！！！ 请经过自行思考再进行观看！！！ 1. 考核要求 # 信息概要：\n学 数据结构 整本书 [[链表]]学生管理系统 禁用STL 增加、删除 查询、显示 保存TXT文件 类型: 姓名、性别、年龄、Other 既然禁用STL 我是不是可以把STL库原内容复制过来🤓👆\n2. 框架整体 # 2.1 安全输入 # 方法一：string安全输入 # string input; getline(cin,input); if(input==\u0026#34;add\u0026#34;){ //TODO }else if(input==\u0026#34;\u0026#34;){ //TODO } 方法二：控制台程序的命令行参数输入 # int main(int argc,char* argv[]){ //使用示例 cout\u0026lt;\u0026lt;argc\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;各个参数\u0026#34;\u0026lt;\u0026lt;endl; for (int i=0;i\u0026lt;argc;++i) cout\u0026lt;\u0026lt;argv[i]\u0026lt;\u0026lt;endl; //再自行做个检测 } 方法三：检查输入 # void clearInput() {/*清除错误状态*/ cin.clear();/*辅助函数，用于清理输入流*/ cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); /*忽略错误输入*/ printf(\u0026#34;非法输入，请重新输入！\\n\u0026#34;); } if(cin.fail()||非目标条件){ clearInput(); } 2.2 链表结构 # //结构A typedef struct STU{ string name; string sex; int age; struct STU* next; //结构B //STU(const string\u0026amp; n, const string\u0026amp; s, int a) : name(n), sex(s), age(a), next(nullptr) {} }STU; //侧重抽象，但简单好用(确信 后记一点也不好用 //欸，我有一个大胆的想法🤓👆 typedef struct STU{ int value; struct STU* next; }STU; //初始化head STU *head = nullptr; 冲动了一下，用第二个方案写完发现，不好用，核心内容全部重写了。。。\n//添加 void add(string name,string sex,int year){ //A结构初始化 STU *newstu = new STU(); newstu-\u0026gt;name = name; newstu-\u0026gt;sex = sex; newstu-\u0026gt;age = year; newstu-\u0026gt;next = nullptr; //B结构初始化 //STU *newstu = new STU(name,sex,age); if(find(name)){ cout\u0026lt;\u0026lt;\u0026#34;错误：已存在此人，不支持\u0026#34;\u0026lt;\u0026lt;endl; return ; } if (head == nullptr) { head = newstu; } else { STU *current = head; while (current-\u0026gt;next != nullptr) { current = current-\u0026gt;next; } current-\u0026gt;next = newstu; } } //删除 void del() { string name=input(); //input()输入内容 STU* current=head; STU* t=nullptr; while(current!=nullptr){ if(current-\u0026gt;name==name){ if(t==nullptr){ // current是头节点 head=current-\u0026gt;next; }else{ t-\u0026gt;next=current-\u0026gt;next; } delete current; cout\u0026lt;\u0026lt;\u0026#34;删除成功！\u0026#34;\u0026lt;\u0026lt;endl; save(); return; } t=current; current=current-\u0026gt;next; } cout\u0026lt;\u0026lt;\u0026#34;错误：不存在此人\u0026#34;\u0026lt;\u0026lt;endl; save(); } //查找 int find(string name=input()){ STU* current = head; while(current != nullptr){ if(current-\u0026gt;name == name){ cout\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; return 1; } current=current-\u0026gt;next; } return 0; } //展示全部 void showall(){ if(head==nullptr)cout\u0026lt;\u0026lt;\u0026#34;无学生信息\u0026#34;\u0026lt;\u0026lt;endl; STU* current = head; while(current != nullptr){ cout\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; current=current-\u0026gt;next; } } 2.3 保存与读取 # //保存 void save(){ ofstream file(\u0026#34;stu.txt\u0026#34;); if(file.is_open()){ STU* current = head; while(current != nullptr){ file\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; current=current-\u0026gt;next; } }else{ printf_red(\u0026#34;错误：无法打开文件\\n\u0026#34;); } } //读取 void read() { ifstream file(\u0026#34;stu.txt\u0026#34;); if(file.is_open()){ string name,sex;int age; while(cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;sex\u0026gt;\u0026gt;age) { add(name,sex,age); } file.close(); }else{ cout \u0026lt;\u0026lt; \u0026#34;错误：无法打开文件or未初始化\u0026#34; \u0026lt;\u0026lt; endl; } } Other辅助 # //颜色输出 void printf_red(const char* s){printf(\u0026#34;\\033[0m\\033[1;31m%s\\033[0m\u0026#34;,s);} void printf_green(const char* s){printf(\u0026#34;\\033[0m\\033[1;32m%s\\033[0m\u0026#34;,s);} // 判空 辅助*input*函数 bool isOnlyspace(const string\u0026amp; str) { for (char ch:str) if(!isspace(ch))return true; return false; } //安全输入(获取一整行数据，然后请自行转换) //注意\u0026#34;name\u0026#34;!=\u0026#34;name \u0026#34; string input(string gd=\u0026#34;姓名：\\n\u0026#34;){ cout\u0026lt;\u0026lt;gd; string str; while(true){ getline(cin,str); if(isOnlyspace(str)) break;else cout\u0026lt;\u0026lt;\u0026#34;重新输入\u0026#34;\u0026lt;\u0026lt;endl; } return str; } // 脑抽加密 // 辅助*read* // 结构特征 获取一整行通过split切割转换成新数据包括空格不会被损失 const string split = \u0026#34;*#^\u0026#34;; vector\u0026lt;string\u0026gt; get(string val){ vector\u0026lt;string\u0026gt; stu; //开切 size_t pos; while ((pos = val.find(split)) != string::npos) { stu.push_back(val.substr(0, pos)); val.erase(0, pos + split.length()); } // for(string i:stu)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return stu; } 最终完成 # 完整代码在考核之后展示，其实已经把所有内容展示了。\n#include \u0026lt;regex\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; #define endl \u0026#39;\\n\u0026#39; void printf_red(const char* s){printf(\u0026#34;\\033[0m\\033[1;31m%s\\033[0m\u0026#34;,s);} void printf_green(const char* s){printf(\u0026#34;\\033[0m\\033[1;32m%s\\033[0m\u0026#34;,s);} // 判空 辅助*input* bool isOnlyspace(const string\u0026amp; str) { for (char ch:str) if(!isspace(ch))return true; return false; } string input(string gd=\u0026#34;姓名：\\n\u0026#34;){ cout\u0026lt;\u0026lt;gd; string str; while(true){ getline(cin,str); if(isOnlyspace(str)) break;else cout\u0026lt;\u0026lt;\u0026#34;重新输入\u0026#34;\u0026lt;\u0026lt;endl; } return str; } typedef struct STU{ string name; string sex; long long age; struct STU* next; STU(const string\u0026amp; n, const string\u0026amp; s, long long a) : name(n), sex(s), age(a), next(nullptr) {} }STU; STU *head = nullptr; const string split = \u0026#34;*#^\u0026#34;; int find(string name=input()){ STU* current = head; while(current != nullptr){ if(current-\u0026gt;name == name){ cout\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; return 1; } current=current-\u0026gt;next; } return 0; } void save(){ ofstream file(\u0026#34;stu.txt\u0026#34;); if(file.is_open()){ STU* current = head; while(current != nullptr){ file\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;split\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;split\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;split\u0026lt;\u0026lt;endl; current=current-\u0026gt;next; } }else{ printf_red(\u0026#34;错误：无法打开文件\\n\u0026#34;); } } void add(string name,string sex,long long age){ if(find(name)){cout\u0026lt;\u0026lt;\u0026#34;错误：已存在此人，不支持再次添加。\u0026#34;\u0026lt;\u0026lt;endl;return ;} STU *newstu = new STU(name, sex, age); if (head == nullptr) { head = newstu; } else { STU *current = head; while (current-\u0026gt;next != nullptr) { current = current-\u0026gt;next; } current-\u0026gt;next = newstu; } save(); } // 辅助*add* void fget(){ string name=input(),sex; while(true){ sex = input(\u0026#34;性别:(男/女)\\n\u0026#34;); if(sex==\u0026#34;男\u0026#34;||sex==\u0026#34;女\u0026#34;) break; } long long age; while(true){ age = atoll(input(\u0026#34;年龄：\\n\u0026#34;).c_str()); if(age==9223372036854775807)cout\u0026lt;\u0026lt;\u0026#34;闲得你这都多少岁了，地球活了这么长了吗？\u0026#34;\u0026lt;\u0026lt;endl; else if(age\u0026lt;=0) cout\u0026lt;\u0026lt;\u0026#34;你确定是负数？\u0026#34;\u0026lt;\u0026lt;endl; else break; } add(name,sex,age); } void del() { string name=input(); STU* current=head; STU* t=nullptr; while(current!=nullptr){ if(current-\u0026gt;name==name){ if(t==nullptr){ // current是头节点 head=current-\u0026gt;next; }else{ t-\u0026gt;next=current-\u0026gt;next; } delete current; cout\u0026lt;\u0026lt;\u0026#34;删除成功！\u0026#34;\u0026lt;\u0026lt;endl; save(); return; } t=current; current=current-\u0026gt;next; } cout\u0026lt;\u0026lt;\u0026#34;错误：不存在此人\u0026#34;\u0026lt;\u0026lt;endl; save(); } void showall(){ if(head==nullptr)cout\u0026lt;\u0026lt;\u0026#34;无学生信息\u0026#34;\u0026lt;\u0026lt;endl; STU* current = head; while(current != nullptr){ cout\u0026lt;\u0026lt;current-\u0026gt;name\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;sex\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;current-\u0026gt;age\u0026lt;\u0026lt;endl; current=current-\u0026gt;next; } } // 辅助*read* vector\u0026lt;string\u0026gt; get(string val){ vector\u0026lt;string\u0026gt; stu; //开切 size_t pos; while ((pos = val.find(split)) != string::npos) { stu.push_back(val.substr(0, pos)); val.erase(0, pos + split.length()); } // for(string i:stu)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return stu; } void read() { ifstream file(\u0026#34;stu.txt\u0026#34;); if(file.is_open()){ string every; while(getline(file,every)) { vector\u0026lt;string\u0026gt; stu = get(every); if(stu.size()\u0026gt;=3) add(stu[0], stu[1], atoi(stu[2].c_str())); else cerr\u0026lt;\u0026lt;\u0026#34;错误：行格式不正确: \u0026#34;\u0026lt;\u0026lt;every\u0026lt;\u0026lt;endl; } file.close(); }else{ cout \u0026lt;\u0026lt; \u0026#34;错误：无法打开文件or未初始化\u0026#34; \u0026lt;\u0026lt; endl; } } int main(){ read(); string op; while(true){ printf_green(\u0026#34;\u0026gt; \u0026#34;); getline(cin,op); if(op==\u0026#34;help\u0026#34;){ printf(\u0026#34;请直接输入选项\\n\u0026#34;); printf(\u0026#34;%s%20s\u0026#34;,\u0026#34;add \u0026#34;,\u0026#34;增加学生信息\\n\u0026#34;); printf(\u0026#34;%s%20s\u0026#34;,\u0026#34;del \u0026#34;,\u0026#34;删除学生信息\\n\u0026#34;); printf(\u0026#34;%s%20s\u0026#34;,\u0026#34;find \u0026#34;,\u0026#34;查询学生信息\\n\u0026#34;); printf(\u0026#34;%s%20s\u0026#34;,\u0026#34;show \u0026#34;,\u0026#34;展示学生信息\\n\u0026#34;); printf(\u0026#34;%s%20s\u0026#34;,\u0026#34;about\u0026#34;,\u0026#34;关于管理系统\\n\u0026#34;); }else if(op==\u0026#34;add\u0026#34;){ fget(); }else if(op==\u0026#34;del\u0026#34;){ del(); }else if(op==\u0026#34;find\u0026#34;){ if(!find())cout\u0026lt;\u0026lt;\u0026#34;错误：不存在此人\u0026#34;\u0026lt;\u0026lt;endl; }else if(op==\u0026#34;show\u0026#34;){ showall(); }else if(op==\u0026#34;about\u0026#34;){ cout\u0026lt;\u0026lt;\u0026#34;一个简单学生管理系统。\\n\u0026#34;; }else if(op==\u0026#34;exit\u0026#34;){ return 0; }else{ printf_red(\u0026#34;错误：非法输入，查看指令请输入help\\n\u0026#34;); } } } ","date":"13130-01-11","externalUrl":null,"permalink":"/posts/uit2024%E5%AF%92%E5%81%87test1/","section":"时间","summary":"","title":"UIT2024寒假1","type":"posts"},{"content":"","date":"13130-01-11","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":"","date":"13130-01-11","externalUrl":null,"permalink":"/tags/%E8%80%83%E6%A0%B8/","section":"Tags","summary":"","title":"考核","type":"tags"},{"content":"","date":"111124-01-11","externalUrl":null,"permalink":"/posts/","section":"时间","summary":"","title":"时间","type":"posts"},{"content":"","date":"111124-01-11","externalUrl":null,"permalink":"/tags/%E9%93%BE%E8%A1%A8/","section":"Tags","summary":"","title":"链表","type":"tags"},{"content":"这是链表，啥东西都没有。\n回头或许会写东西。。\n","date":"111124-01-11","externalUrl":null,"permalink":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","section":"时间","summary":"","title":"链表","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"LixWorthの博客\n","externalUrl":null,"permalink":"/friends/","section":"友情链接","summary":"","title":"友情链接","type":"friends"}]